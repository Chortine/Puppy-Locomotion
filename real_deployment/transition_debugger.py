from collections import deque
import os
import pickle
import matplotlib.pyplot as plt
import numpy as np


class TransitionDebugger:
    """
    This is to collect sequence of obs-action pair in simulation,
    and feed the sequence of obs in reality/simulation to see if they generate the same sequence of actions
    """

    def __init__(self, mode, sequence_len, transition_path):
        """
        :param mode:
        1. collect: to collect the real transitions that generated by agent
        2. replay: replay the sequence of obs and compare the 'fake' actions with the real actions
        """
        assert mode in ['collect', 'replay']
        self.mode = mode
        self.transition_path = transition_path
        self.sequence_len = sequence_len - 1
        if self.mode == 'collect':
            self.obs_deque = deque(maxlen=sequence_len)
            self.action_deque = deque(maxlen=sequence_len)
            self.toe_pose_deque = deque(maxlen=sequence_len)
        elif self.mode == 'replay':
            with open(os.path.join(self.transition_path, 'transitions.pickle'), 'rb') as handle:
                data_dict = pickle.load(handle)
            self.obs_deque = data_dict['obs_deque']
            self.action_deque = data_dict['action_deque']
            self.toe_pose_deque = data_dict['toe_pose_deque']
            self.toe_pose_deque = deque(maxlen=sequence_len)
            self.real_obs_deque = deque(maxlen=sequence_len)
            self.real_action_deque = deque(maxlen=sequence_len)
            self.real_toe_pose_deque = deque(maxlen=sequence_len)

    def step(self, obs, action, toe_pose):
        print(f'obs lefted to replay {len(self.obs_deque)}')
        """

        :param obs:
        :param action: action that causes this obs
        :return:
        """
        if self.mode == 'collect':
            self.obs_deque.append(obs)
            self.action_deque.append(action)
            self.toe_pose_deque.append(toe_pose)

            if len(self.obs_deque) == self.sequence_len:
                # save the data_dict
                data_dict = {'obs_deque': self.obs_deque,
                             'action_deque': self.action_deque,
                             'toe_pose_deque': self.toe_pose_deque}

                with open(os.path.join(self.transition_path, 'transitions.pickle'), 'wb') as handle:
                    pickle.dump(data_dict, handle, protocol=pickle.HIGHEST_PROTOCOL)
                print('++++++++++ transitions data saved !!')

        elif self.mode == 'replay':
            if len(self.real_action_deque) < self.sequence_len - 1:
                obs = self.obs_deque.popleft()
                self.real_obs_deque.append(obs)
                self.real_action_deque.append(action)
                self.real_toe_pose_deque.append(toe_pose)
            elif len(self.real_action_deque) == self.sequence_len - 1:
                self.real_action_deque.append(action)
                data_dict = {'obs_deque': self.real_obs_deque,
                             'action_deque': self.real_action_deque,
                             'toe_pose_deque': self.real_toe_pose_deque}
                with open(os.path.join(self.transition_path, 'replay_transitions.pickle'), 'wb') as handle:
                    pickle.dump(data_dict, handle, protocol=pickle.HIGHEST_PROTOCOL)
                print('++++++++++ replay transitions data saved !!')
                self._compare()

        return obs

    def _compare(self):
        """
        compare action_deque and real_action_deque
        :return:
        """
        print('test')
        actions = np.asarray(self.action_deque)
        real_actions = np.asarray(self.real_action_deque)

        error = np.sum(abs(actions[:np.shape(real_actions)[0], :] - real_actions))
        print(f'error = {error}')
        
        plt.plot(np.asarray(self.action_deque)[:, 0])
        plt.plot(np.asarray(self.real_action_deque)[:, 0])
        plt.show()
        
        print('end')

